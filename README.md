# Java基础复习

# JavaSE
```text
🌳 线程
程序:为完成特定的任务，用某种语言编写的一组指令的集合
进程:是程序的依次执行或是正在运行的一个程序
线程:进程可以进一步细化为线程，是一个程序内部的一条执行路径

重点:
😊线程的创建和使用
😊线程的生命周期
😊线程的同步
😊线程的通信

重点:
一个Java应用程序java.exe，其实至少有三个线程，main()主线程,gc()垃圾回收线程，异常处理线程。如果发生异常会影响main主线程

重点:
并行:多个CPU同时执行多个任务
并发:一个CPU（采用时间片）同时执行多个任务

重点:
多线程的创建方式
🍒 继承Thread类， 重写run方法，start方法启动线程
🍒 实现Runnable接口, 重写run方法， 调用start方法启动线程
🍒 实现Callable接口, Callable功能更强大些
🍒 线程池
比较线程创建方式:
🚗 开发中优先选择实现runnable接口的方式
🚗 实现的方式没有单继承的局限性
🚗 实现的方式更适合处理多个线程有共享数据的情况
🚗 两种方式都是需要重写run方法，将线程需要执行的逻辑申明在run方法中
实现Callable接口比Runnable接口强大:
Callable接口可以有返回值
Callable可以抛出异常
callable支持泛型


线程的调度
调度策略: 时间片、抢占式高优先级的线程抢占CPU
Java的调度方法:同优先级线程组成先进先出队列（先到先服务），使用时间片策略。对高优先级，使用优先调度的抢占式策略

线程优先级
MAX_PRIORITY: 10
MIN_PRIORITY: 1
NORM_PRIORITY: 5
线程创建时继承父线程的优先级
低优先级只是获得调度的概率低， 并非一定是在高优先级线程之后才会被调用

JVM中只剩守护线程时，JVM将退出

重点:
线程的生命周期:
Thread.state 有几种状态
new: 新建
start: 就绪
runnable: 运行
blocked: 阻塞
waiting: 
timed_waiting
dead: 死亡

线程的同步:
同步代码块:
    synchronized
    共享数据
    同步监视器: 简称'锁'，任一个类的对象都可以充当锁, 多个线程必须要公用一把锁
    
同步方法:
    同步方法仍然涉及到同步监视器， 只是不需要我们显示的声明
    非静态的同步方法， 同步监视器是this
    静态的不同步方法， 监视器是当前类本身

死锁:
不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的资源，就形成了线程的死锁。
出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续。
解决办法:


Lock锁:
synchronized和lock的区别？
🍎 相同点：两者都可以解决线程安全问题
🍎 不同点：synchronized机制执行完相应的同步代码块，会自动释放同步监视器
         lock需要手动启动同步lock，手动结束同步unlock
优先使用顺序:lock > 同步代码块 > 同步方法


线程的通信:
线程通信涉及的三个方法:
这三个方法使用的前提:必须使用在同步代码块或同步方法中, 调用这三个方法的调用者必须是同步代码块或同步方法中的同步监视器
🍊 wait方法: 一旦执行此方法，当前线程就进入阻塞状态， 并释放同步监视器
🍊 notify方法: 一旦执行此方法，就唤醒被wait的一个线程， 如果多个线程被wait，则唤醒优先级高的那个线程
🍊 notifiAll方法: 一旦执行此方法， 就会唤醒所有wait的线程
这三个方式是定义在Object对象中的



sleep和wait的区别:
🍑 相同点: 一旦执行这两个方法都可以使得当前的线程进入阻塞状态
🍑 不同点: 两个方法声明的位置不同， Thread类中声明sleep方法， object类中声明了wait方法
          调用的要求不同， sleep可以在任何需要的场景下调用，wait必须使用在同步代码块中
          关于是否释放同步监视器:如果两个方法都使用在同步代码块或同步方法中，sleep不会释放锁，wait会释放锁
          

重点
Java常用类

🥝 字符串相关的类

🥝 日期时间(JDK8前后API对比)

🥝 Java比较器

🥝 System类

🥝 Math类

🥝 BigInteger与BigDecimal



```
# JavaEE
```text

```
# JavaME

# remarks
```text

mstsc 近程桌面; 远程桌面; 远程桌面连接; 远程连接; 远端桌面;

```